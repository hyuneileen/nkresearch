김일성종합대학학보 정보과학 주체110(2021)년 제67권  제3호 쏘프트웨어의 재분해를 위한 코드결함의 식별방법 신춘옥, 김충혁 쏘프트웨어재분해를 효률적으로 진행하자면 코드에 내재되여있는 결함(Bad Smells)의 종류뿐아니라 그것의 원인으로 되는 쏘프트웨어의 실체들과 그 포괄범위들을 정확히 반 영하여 코드결함식별방법을 정량적으로, 론리적으로 정식화하여야 한다. 선행연구[1, 3]에서는 코드결함을 측정량에 기초하여 식별하고 선행연구[2]에서는 오 유예측을 위하여 코드결함식별원리를 론리적으로 정식화하였다. 그러나 쏘프트웨어재분해와 관련한 요구 그리고 코드결함으로 되는 코드부분을 정확 하게 반영하지 않았다. 론문에서는 매 코드결함들을 쏘프트웨어의 실체들과 여러 측정량들과의 련관속에서 론리적으로 정식화하여 코드에 내재되여있는 결함들의 종류와 그 결함이 있는 코드부분 을 정확히 식별하는 방법을 제안하였다. １．측정지표들과 1계술어론리식에 의한 코드결함들의 정의 코드결함을 정량적으로 론의하기 위하여 선행연구[2]의 측정지표들을 쏘프트웨어의 구성요소들과의 관계속에서 수정보충한다. 코드결함식별에서 리용되는 측정지표들과 그 정의를 표 1에 보여주었다. 표 １．코드결함식별에서 리용되는 측정지표들과 그 정의 정의 측정중인 클라스 c와 무관계한 클라스들에서 정의되고 클라스 c로부터 직접 접근되거나 혹은 접근자메쏘드호출에 의하여 접근되는 속성들의 모임이다. 즉 ATFD call ( accessor, 이다. ∧′∈ c access |{ aa ,( ac )( c ))} ∨ = a ) ( 현재의 클라스들에서 선언되였으며 측정중인 메쏘드 m에 의하여 직접 접근 되거나 혹은 접근자메쏘드호출에 의하여 접근되는 속성들의 모임이다. 즉 am ATLD , cmc ∧∈∧∈ accessor, (access( 이다. |{) = call ( aa ))} m ∨ a ) ( 측정하려는 메쏘드 m을 호출하는 메쏘드들이 정의된 클라스들의 모임이다. 즉 call ( ∧≠∧′∈′∧∈ ′= |{ cmcmc 이다. ′ , mm (CC )} m c c ) 측정하려는 메쏘드 m으로부터 호출되는 메쏘드들이 정의된 클라스들의 수를 |CINT|로 나눈 값이다. 즉 ′ |{| cmc 이다. ∧′∈′ ′ |/|)} CINT mm , call ( | 측정하려는 메쏘드 m으로부터 호출되는 구별가능한 메쏘드들의 모임이다. 즉 이다. CINT mm , call ( m { ′ )} m = ( ) ′ | 측정중인 메쏘드 m을 호출하는 구별가능한 메쏘드들의 모임이다. 즉 (CM 이다. , mm call ( { m ′ )} m = ) ′ | 메쏘드 m에서 선형인 독립경로의 최대수(대응하는 코드의 실행흐름에서 분 기가 없으면 경로는 선형임.)이다. 측정지표 ATFD(c) ATLD(m) CC(m) CDISP(m) CINT(m) CM(m) CYCLO(m) 표계속 측정지표 DBMC(m, c) FANOUT(m) LOC() NOMP(c1, c2) MeMCL(m) NMCS(m) NOAM(c) NOLV(m) NOMNAMM(c) NOPA(c) NOPR(m) TCC(c) － 16 － 종합대학학보 정보과학 주체110(2021)년 제67권 제3호 정 의 c ) m m | | S S cm , ∩ ∪ 1 −= DBMC ( 거리이다. 여기서 에 의하여 계산하는 메쏘드 m과 클라스 c사이의 S | | S mS 은 메쏘드 m이 접근하는 실체들의 모임이고 cS 는 c에 속하는 메쏘드들과 속성들을 포함하는 모임(m이 클라스 c에 속하면 m을 제외 함.)이다.   메쏘드 m에서 호출되는 클라스의 수이다. 즉 이다. call ( cm , c |{| |)} c LOCNAM(c) 메쏘드 혹은 클라스의 코드행의 수(공백행과 주석을 포함.)이다.   접근자와 변이자메쏘드들과 그것에 해당한 주석들을 제외한 클라스 c에서 코드행의 수(공백행과 주석을 포함.)이다.   메쏘드 m에서 사슬로 된 호출의 최대길이이다.  MAXNESTING(m)  메쏘드 m의 조종구조에서 최대의 중첩준위이다.  1c 과 클라스 2c 사이 통보문넘기기의 수이다. MaMCL(m) 클라스 메쏘드 m에서 사슬로 된 호출의 평균길이이다.   메쏘드 m에서 서로 다른 사슬화된 호출의 수이다.   클라스 c에 있는 접근자메쏘드들의 수이다. 즉 {|  메쏘드 m에서 선언된 국부변수들의 수이다. 즉 lv |{| accessor | accessor mlv ∈ |} + NOR( |} c∈ 이다.  이다. ) m 측정중인 클라스 c에서 국부적으로 정의되는 메쏘드들의 수이다. 즉 |{| dm . accessor ∧  클라스 c에 있는 공개속성의 수이다. 즉 |} 이다. mcmm dacaa . ∧∈ 이다. mutator public} private public ∧∈ |{| dm . m ∧ ∨ ≠ ≠ = = = | 메쏘드 m의 형식적파라메터목록의 길이이다.   측정중인 클라스 c에서 실체변수들을 통하여 다른 메쏘드와 직접 련결된 메 쏘드들의 수와 메쏘드들사이의 가능한 총 련결수사이의 비률이다. 즉  cmcmc , , : mm , directconn ected ∈∃′ |) cmcm , ′ /|) connected mma ,( , : mm , mm , a ∈∃ ′ |)} ′ |)} ∈′ {(| {(| ∈ ∈ ( 이다. TCC는 [0, 1]범위의 값을 가진다.   클라스 c에서 정의된 메쏘드들(접근자 혹은 변이자는 제외함.)의 복잡도 WMCNAMM(c) CYCLO의 합이다. 즉 ∑ CYCLO ( ) m mutator ≠∧ m 이다. mcm ≠∧∈ accessor 클라스 c에서 비추상적이면서 접근자도 변이자도 아닌 어떤 기능을 수행하 는 공개메쏘드들의 수를 공개메쏘드들의 총수로 나눈 값이다. 즉 WOC(c) |{| . dmcmm ∧∈ = public m ≠∧ abstract m ≠∧ accessor ∧ m ≠ mutator |{|/|} . dmcmm ∧∈ = public} | 이다. 표 1에서 파라메터 c 는 클라스를, m 은 메쏘드를, a 는 속성을, xx , ′ 는 x 가 x′ 에 접근하는 관계를, ) dx. 는 실체 x 의 호 ′ 는 x 가 ) xx ,( call 출지정자를 지적하며 술어 access( x′ 를 호출하는 관계를 표현한다. 두  메 쏘 드  m 과  m′ 가  같 은  실 체 변 수  a 에  메 쏘 드 호 출 을  통 하 여  직 접  혹 은  간 접 적으로 접근하는 관계(이 경우 두 메쏘드는 직접 련결되였다고 함.)에 있을 때 ′ 는 참이며 두 메쏘드 m 과 m′ 사이의 가능한 련결을 술어  술어 directconnected ) mma ,( , 쏘프트웨어의 재분해를 위한 코드결함의 식별방법 － 17 － , ) mm ′ 로 표시한다. Xx ∈ 는 쏘프트웨어의 구성요소 x 가 X 를 정의하는 코 connected( 드본체에서 선언되거나 정의될 때 참으로 되는 술어이다. 코드결함들의 종류를 코드결함 이 있는 실체를 파라메터로 하는 단항술어(실례로 c ) 또는 코드결함을 일으 ) 키는 요소들사이의 관계술어(실례로 Envy( 각이한 코드결함을 1계론리식에 의하여 정식화한다. 그 론리식들에서 따름연산의 전 제부를 이루는 부분론리식들은 해당 코드결함의 식별조건이고 결론부는 코드결함의 종류 를 지적하는 술어이다. 결론부를 이루는 술어의 항들은 그 코드결함의 원인으로 되며 다 음단계에서 재분해를 하여야 할 쏘프트웨어요소(메쏘드, 클라스, 클라스모임)들이다. )로 표기한다. God ) Feature Class( cm , 각이한 코드결함의 정의를 표 2에 보여주었다. 표 ２．각이한 코드결함의 정의 코드결함식별을 위한 1계론리식 코드결함종류 God Class Feature Envy Data Class Brain Method ((LOCKNAMM(c) ≥ 176) ∧ (WMCNAMM(c) ≥ 22) ∧ (NOMNAMM(c) ≥ 18) ∧ (TCC(c) ≤ 0.33) ∧ |(ATFD(c)| ≥ 6)) ⇒ God Class(c) cm , ((DBMC(m, c)－DBMC ∧′≠ c ) cm ∈∃ (: ( Inappropriate Iintimacy (NOMP ( ) ⇒≥ )3 Inappropriate Intimacy ( ⇒>′ )) ) β 1 cc , 2 ) Feature Envy cc ,( ′ ) (WMCNAMM(c) ≤ 14) ∧ (WOC(c) ≤ 0.33) ∧ (NOAM(c) ≥ 4) ∧ (NOPA(c) ≥ 3) ⇒ c c 1 c , 2 Data class(c) (LOC(m) ≥ 33) ∧ (CYCLO(m) ≥ 7) ∧ (MAXNESTING(m) ≥ 6) ∧ (NOLV(m) ≥ 6) ∧ (|ATLD(m)| ≥ 5) ⇒ Brain Method(m) cm ∈∃ :(|CC(m)| ≥ 5) ∧ (|CM(m)| ≥ 6) ∧ (FANOUT(m) ≥ 3) ⇒ Shotgun Surgery(c, Shotgun Surgery CC(m)) Dispersed Coupling Message Chains Long Method Large Class Long Parameter List(m) cm ∈∃ :(|CINT(m)| ≥ 8) ∧ (CDISP(m) ≥ 0.66) ⇒ Dispersed Coupling(c) ((MaMCL(m) ≥ 3) ∧ (NMCS(m) ≥ 3) ∧ (MeMCL(m) ≥ 2)) ⇒ Message Chains(m) Loc(m) ≥ 50 ∨ CYCLO(m) ≥ 11 ⇒ Long Method(m) Loc(c) ≥ 100 ≥ 21 ⇒ Large Class(c) cm ∈∃∨ CYCLO m ( ) : NOPR(m) ≥ 5 ⇒ Long Parameter List(m) ２．코드결함들의 식별방법 코드결함식별에서는 매 코드결함을 정식화한 론리식의 전제부를 이루는 부분론리식 을 식별조건으로 한다. 그 식별조건이 성립하는가를 판별하여 코드결함의 종류와 그 결 함을 가지는 또는 원인으로 되는 코드요소들을 식별한다. 매 코드결함의 식별방법은 다음과 같다.  ① God Class의 식별 God Class의 식별조건을 이루는 다음의 매 관계식이 성립하는가를 판별한다. 여기서 getter와 setter메쏘드들을 가지는 클라스, getter와 setter메쏘드들을 가지지 않는 클라스가 God class로 검출될수 있는 확률이 같다는 사실을 고려한다. ·LOCKNAMM ≥c )( 176 은 측정중인 클라스 c에 코드가 너무 많을 때 성립한다. getter와 setter메쏘드들은 IDE에서 생성되므로 LOC대신에 LOCKNAMM을 리용한다. ·WMCNAMM 는 클라스 c 가 수행하는 작업량이 많고 복잡할 때 성립한다. 매 메쏘드는 적어도 최소한의 순환복잡도를 가지므로 getter와 setter메쏘드들도 그 클라스 ≥c )( 22 － 18 － 종합대학학보 정보과학 주체110(2021)년 제67권 제3호 의 순환복잡도를 높인다. 따라서 그것들을 제외한 복잡도측정량을 리용한다. ·NOMNAMM 은 클라스 c 에 많은 기능들이 들어있을 때 성립한다. 그 클라 스의 기능성을 효과적으로 실현하는 메쏘드들만 론의하여야 하므로 getter와 setter메쏘드 들은 제외시킨다. ≥c )( 18 ·TCC ≤c )( 33.0 은 클라스 c 의 함수들이 서로 다른 과제들을 수행하는것으로 하여 c 의 응집도가 낮아지지 않는가를 판정하기 위한것이다. ·|ATFD )(c | 6≥ 은 측정중인 클라스 c 가 다른 클라스의 자료들을 정도이상으로 많 이 리용할 때 참으로 된다. 매 관계식들이 성립하여 식별조건이 참으로 되면 측정중인 클라스 c 는 God Class로 판정되며 클라스추출 또는 메쏘드추출연산을 적용하여야 할 코드부분으로 된다. ② Feature Envy의 식별 Feature Envy의 식별조건인 c (: cm ∈∃ ∧′≠ c ) 는 측정중인 메쏘드 m 이 클라스 c 에서 정의되고 메쏘드 m 과 클라스 c 의 거리가 클라스 c′ 와의 거리보다 더 클 때(즉 m 이 c 보다 c′ 와 밀접한 관계가 있을 때) 성립한다. 식별 조건이 성립하면 클라스 c 와 클라스 c′ 는 Feature Envy관계에 있다. 즉 메쏘드 m 과 그 것이 정의된 클라스 c , 관계가 보다 밀접한 c′ 는 Feature Envy코드결함이 내재하고있는 코드부분이다. DBMC DBMC β>′ )) cm , cm , − ( ( ) ( ③ Inappropriate Intimacy의 식별 Inappropriate Intimacy의 식별조건인 NOMP 가 있어 NOMP Inappropriate Intimacy관계에 있으며 재분해의 대상으로 된다. 1 cc , ) ( 2 c 2 가 턱값 3보다 크면 참으로 된다. 이때 클라스들의 쌍 은 측정중인 두 클라스 ( c 1 ≥ 3 ) ( , 1c 과 1 cc , ) 2 2c 는 ④ Data Class의 식별 Data Class의 식별조건에서 WMCNAMM 복잡하지 않다는것을, WOC 한다. )( ≤c 는 측정중인 클라스 c의 메쏘드들이 은 클라스 c 가 적은 기능들을 제공한다는것을 의미 14 )( ≤c 33.0 는 클라스 c 가 많은 접근자메쏘드를 가질 때 참으로 된다. 4 )( ≥c 은 클라스 c 가 많은 공개속성을 가질 때 참으로 된다.  )( ≥c 3 NOAM NOPA 우의 관계식들이 다 참으로 되면 클라스 c 는 Data Class이다.  ⑤ Brain Method의 식별 Brain Method의 식별조건에서 관계식 LOC 33 ( 은 측정중인 메쏘드 m 의 코드행 은 메쏘드 m 의 순환복잡도가 높다는것을 의미한다.  은 메쏘드 m 에 준위가 깊은 어떤 겹순환이 있어 리해하기가 ≥m ) ≥m ) 7 ( 이 매우 많다는것을, CYCLO ≥m ) MAXNESTING 어렵다는것을 의미한다. ( 6 측정중인 메쏘드 m 은 우의 세 관계식이 참일 때 Brain Method이다.  다음의 두 관계식이 참일 때에도 m 을 Brain Method로 식별한다.  NOLV 은 메쏘드 m 에 국부변수의 수가 많아 리해하기가 어렵다는것을 의미 ≥m ) 6 ( 한다. ( ≥m |) 는 메쏘드 m 이 클라스의 자료들을 많이 리용할 때 참으로 된다. 5 |ATLD ⑥ Shotgun Surgery의 식별 Shotgun Surgery는 쏘프트웨어의 여러 요소들사이에 존재하는 그중 복잡한 형태의 코 드결함이다. 쏘프트웨어의 재분해를 위한 코드결함의 식별방법 － 19 － Shotgun Surgery의 식별조건에서 는 측정중인 클라스 c 에서 정의 된 메쏘드 m 을 호출하는 메쏘드들이 서로 다른 적지 않은 클라스들의 모임 CC(m)에서 정의되였다는것을 의미한다.  6 은 메쏘드 m 을 호출하는 메쏘드들의 수 즉 메쏘드 m 을 변화시킬 때 (CC:| cm ∈∃ (CM| |) ≥m m |) ≥ 5 함께 변화시켜야 할 메쏘드의 수가 아주 많다는것을 의미한다. ( FANOUT 관계식들이 참으로 될 때 쏘프트웨어요소 m 과 c , CC(m)의 매 클라스들은 Shotgun 은 그 메쏘드 m 이 변화되여야 할 대상이라는것을 의미한다. ≥m ) 3 Surgery를 이룬다. ⑦ Dispersed Coupling의 식별 Dispersed Coupling의 식별조건에서 CINT ( ≥m ) 8 은 클라스 c 에 속하는 어떤 메쏘드 m 이 정도이상의 다른 메쏘드들을 호출할 때 참으로 된다. CDISP(m) ≥ 0.66은 클라스 c에 속하는 어떤 메쏘드 m 에 대한 호출이 너무 많은 클 라스들에 분산되여있을 때 참으로 된다. 관계식들이 모두 참일 때 클라스 c는 Dispersed Coupling코드결함을 가진다.  ⑧ Message Chain의 식별 Message Chain의 식별조건에서 MaMCL(m) ≥ 3은 메쏘드 m 이 적어도 평균보다 큰 길 이를 가지는 사슬로 된 호출을 가질 때 참으로 된다. NMCS(m) ≥ 3은 통보문사슬명령문의 수를 의미한다. 보다 많은 통보문사슬명령문과 호출의 각이한 사슬들이 있을수 있다. MeMCL(m) ≥ 2는 메쏘드 m 이 평균통보문사슬길이보다 큰 통보문사슬을 가질 때 참 으로 된다. 한다. 이다. 이다. 관계식들이 참으로 되면 메쏘드 m은 Message Chain의 코드결함을 가지는것으로 판정 ⑨ Long Method의 식별 측정중인 메쏘드 m은 다음의 두 관계식들중의 어느 하나가 참으로 되면 Long Method Loc(m) ≥ 50 CYCLO(m) ≥ 11 ⑩ Large Class의 식별 측정중인 클라스 c는 다음의 두 관계식들중의 어느 하나가 참으로 되면 Large Class Loc(c) ≥ 100 cm ∈∃ : CYCLO(m) ≥ 21 ⑪ Long Parameter List의 식별 측정중인 메쏘드 m은 NOPR(m) ≥ 5일 때 Long Parameter List의 코드결함을 가진다. 맺 는 말 매 코드결함들을 쏘프트웨어의 실체들과 여러 측정량들과의 관계속에서 론리적으로 정식화하여 코드에 내재하는 코드결함의 종류와 그 결함이 있는 코드부분을 정확히 식별 할수 있게 하였다. － 20 － 종합대학학보 정보과학 주체110(2021)년 제67권 제3호 참 고 문 헌 [1] Santiago Vidal et al.; ACM Transactions of Software Engineering and Methodology, 27, 1, 2, 2018. [2] Fabio Palomba et al.; IEEE Transactions on Software Engineering, 45, 2, 194, 2019. [3] Hui Liu et al.; IEEE Transations on Software Engineering, 38, 1, 220, 2012. An Identification Method of Code Smells for Software Refactoring 주체110(2021)년 5월 5일 원고접수 Sin Chun Ok, Kim Chung Hyok In this paper, we have proposed an identification method of code smells that can correctly identify the kinds of bad smells and its entities for software refactoring. Keywords: code smells, refactoring, predicate logic